diff --git a/old_product.java b/new_product.java
index 9cd1d38..ee6f783 100644
--- a/old_product.java
+++ b/new_product.java
@@ -1,4 +1,4 @@
-private static boolean isEvent(ByteBuffer buffer, Class<?> eventClass, ClassLoader classLoader) throws IOException {
+private static boolean isEvent(ByteBuffer buffer, Class<?> eventClass) throws IOException {
 		if (buffer.remaining() < 4) {
 			throw new IOException("Incomplete event");
 		}
@@ -10,38 +10,16 @@ private static boolean isEvent(ByteBuffer buffer, Class<?> eventClass, ClassLoad
 		try {
 			int type = buffer.getInt();
 
-			switch (type) {
-				case END_OF_PARTITION_EVENT:
-					return eventClass.equals(EndOfPartitionEvent.class);
-				case CHECKPOINT_BARRIER_EVENT:
-					return eventClass.equals(CheckpointBarrier.class);
-				case END_OF_SUPERSTEP_EVENT:
-					return eventClass.equals(EndOfSuperstepEvent.class);
-				case CANCEL_CHECKPOINT_MARKER_EVENT:
-					return eventClass.equals(CancelCheckpointMarker.class);
-				case OTHER_EVENT:
-					try {
-						final DataInputDeserializer deserializer = new DataInputDeserializer(buffer);
-						final String className = deserializer.readUTF();
-
-						final Class<? extends AbstractEvent> clazz;
-						try {
-							clazz = classLoader.loadClass(className).asSubclass(AbstractEvent.class);
-						}
-						catch (ClassNotFoundException e) {
-							throw new IOException("Could not load event class '" + className + "'.", e);
-						}
-						catch (ClassCastException e) {
-							throw new IOException("The class '" + className + "' is not a valid subclass of '"
-								+ AbstractEvent.class.getName() + "'.", e);
-						}
-						return eventClass.equals(clazz);
-					}
-					catch (Exception e) {
-						throw new IOException("Error while deserializing or instantiating event.", e);
-					}
-				default:
-					throw new IOException("Corrupt byte stream for event");
+			if (eventClass.equals(EndOfPartitionEvent.class)) {
+				return type == END_OF_PARTITION_EVENT;
+			} else if (eventClass.equals(CheckpointBarrier.class)) {
+				return type == CHECKPOINT_BARRIER_EVENT;
+			} else if (eventClass.equals(EndOfSuperstepEvent.class)) {
+				return type == END_OF_SUPERSTEP_EVENT;
+			} else if (eventClass.equals(CancelCheckpointMarker.class)) {
+				return type == CANCEL_CHECKPOINT_MARKER_EVENT;
+			} else {
+				throw new UnsupportedOperationException("Unsupported eventClass = " + eventClass);
 			}
 		}
 		finally {
